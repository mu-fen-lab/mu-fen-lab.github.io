<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»æµå‘å±•æ—¶é—´è½´</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: "Microsoft YaHei", sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        /* äº‹ä»¶æ—¶é—´è½´ */
        .timeline {
            width: 25%;
            overflow-y: hidden;
            position: relative;
            background: #ffffff;
            border-radius: 8px;
            padding: 15px;
        }

        .event-container {
            position: relative;
            height: 100%;
        }

        .event-card {
            background: #f8f9fa;
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.8s ease;
        }

        .event-card:hover {
            background: #e9ecef;
        }

        /* ä¸»å›¾è¡¨åŒº */
        .chart-box {
            flex: 1;
            position: relative;
            background: #ffffff;
            border-radius: 8px;
            padding: 15px;
        }

        #mainChart {
            width: 100%;
            height: 100%;
        }

        /* æˆæœå±•ç¤ºåŒº */
        .achievement {
            width: 25%;
            padding: 15px;
            background: #ffffff;
            border-radius: 8px;
            overflow-y: auto;
        }

        .achievement-card {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        .achievement::-webkit-scrollbar {
            width: 8px;
        }

        .achievement::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .achievement::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .achievement::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                height: auto;
            }
            .timeline, .chart-box, .achievement {
                width: 100%;
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="timeline">
            <div class="event-container" id="eventContainer"></div>
        </div>
        
        <div class="chart-box">
            <canvas id="mainChart"></canvas>
        </div>

        <div class="achievement" id="achievement">
            <h3>2025å‘å±•æˆæœ</h3>
            <div class="achievement-card">ğŸŒ± ç¢³æ’æ”¾å¼ºåº¦ä¸‹é™18.5%</div>
            <div class="achievement-card">ğŸš€ ç ”å‘æŠ•å…¥å¼ºåº¦2.9%</div>
            <div class="achievement-card">ğŸ­ åˆ¶é€ ä¸šå æ¯”27.3%</div>
        </div>
    </div>

<script>
// æ•°æ®æºï¼šå›½å®¶ç»Ÿè®¡å±€å¹´åº¦æŠ¥å‘Š
const dataset = {
    years: [2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025],
    GDP: [68.9,74.4,83.2,91.9,99.1,101.4,114.9,121.0,126.1,131.7,138.0],
    GIP: [35.6,38.9,42.1,45.3,48.5,51.2,54.7,58.3,61.5,64.8,68.2],
    highTechRate: [12.5,13.2,14.1,15.3,16.5,17.8,19.2,20.5,21.8,23.1,24.4],
    events: [
        "2015: ä¸­å›½åˆ¶é€ 2025å¯åŠ¨",
        "2016: ä¾›ç»™ä¾§æ”¹é©æ·±åŒ–",
        "2017: åä¹å¤§æå‡ºé«˜è´¨é‡å‘å±•",
        "2018: ç¯ä¿æ”»åšæˆ˜å‡çº§",
        "2019: ç§‘åˆ›æ¿æ­£å¼å¼€å¸‚",
        "2020: åŒå¾ªç¯æ–°å‘å±•æ ¼å±€",
        "2021: ç¢³è¾¾å³°è¡ŒåŠ¨æ–¹æ¡ˆå®æ–½",
        "2022: ä¸“ç²¾ç‰¹æ–°ä¼ä¸šåŸ¹è‚²è®¡åˆ’",
        "2023: ä¸€å¸¦ä¸€è·¯åå‘¨å¹´æˆæœ",
        "2024: æ–°è´¨ç”Ÿäº§åŠ›å»ºè®¾å¹´",
        "2025: ç°ä»£åŒ–äº§ä¸šä½“ç³»å»ºæˆ"
    ]
};

// åŸç”ŸCanvaså›¾è¡¨ç³»ç»Ÿ
function initChart() {
    const canvas = document.getElementById('mainChart');
    const ctx = canvas.getContext('2d');
    
    // è®¾ç½®ç”»å¸ƒå°ºå¯¸
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // å›¾è¡¨é…ç½®
    const config = {
        padding: 40,
        maxValue: Math.max(...dataset.GDP),
        colors: {
            lineGDP: '#2ecc71',
            lineGIP: '#3498db',
            lineHighTech: '#e74c3c',
            grid: '#eee',
            text: '#7f8c8d'
        }
    };

    // ç»˜åˆ¶å›¾è¡¨
    function drawChart(progress) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ç»˜åˆ¶ç½‘æ ¼
        ctx.beginPath();
        ctx.strokeStyle = config.colors.grid;
        for(let i=0; i<=5; i++) {
            const y = canvas.height - config.padding - i*(canvas.height-2*config.padding)/5;
            ctx.moveTo(config.padding, y);
            ctx.lineTo(canvas.width - config.padding, y);
        }
        ctx.stroke();

        // ç»˜åˆ¶GDPçº¿
        ctx.beginPath();
        ctx.strokeStyle = config.colors.lineGDP;
        ctx.lineWidth = 2;
        const step = (canvas.width - 2*config.padding)/(dataset.years.length-1);
        dataset.GDP.slice(0, progress+1).forEach((value, index) => {
            const x = config.padding + index*step;
            const y = canvas.height - config.padding - (value/config.maxValue)*(canvas.height-2*config.padding);
            if(index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            ctx.arc(x, y, 3, 0, Math.PI*2);
        });
        ctx.stroke();

        // ç»˜åˆ¶GIPçº¿
        ctx.beginPath();
        ctx.strokeStyle = config.colors.lineGIP;
        ctx.lineWidth = 2;
        dataset.GIP.slice(0, progress+1).forEach((value, index) => {
            const x = config.padding + index*step;
            const y = canvas.height - config.padding - (value/config.maxValue)*(canvas.height-2*config.padding);
            if(index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            ctx.arc(x, y, 3, 0, Math.PI*2);
        });
        ctx.stroke();

        // ç»˜åˆ¶é«˜æ–°äº§ä¸šç‡çº¿
        ctx.beginPath();
        ctx.strokeStyle = config.colors.lineHighTech;
        ctx.lineWidth = 2;
        dataset.highTechRate.slice(0, progress+1).forEach((value, index) => {
            const x = config.padding + index*step;
            const y = canvas.height - config.padding - (value/config.maxValue)*(canvas.height-2*config.padding);
            if(index === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            ctx.arc(x, y, 3, 0, Math.PI*2);
        });
        ctx.stroke();

        // ç»˜åˆ¶æ ‡ç­¾
        ctx.fillStyle = config.colors.text;
        ctx.font = '12px Arial';
        dataset.years.slice(0, progress+1).forEach((year, index) => {
            const x = config.padding + index*step - 15;
            ctx.fillText(year, x, canvas.height - 20);
        });

        // ç»˜åˆ¶å›¾ä¾‹
        ctx.fillStyle = config.colors.lineGDP;
        ctx.fillRect(config.padding, config.padding - 20, 20, 10);
        ctx.fillStyle = config.colors.text;
        ctx.fillText('GDP', config.padding + 30, config.padding - 10);

        ctx.fillStyle = config.colors.lineGIP;
        ctx.fillRect(config.padding, config.padding - 10, 20, 10);
        ctx.fillStyle = config.colors.text;
        ctx.fillText('GIP', config.padding + 30, config.padding + 10);

        ctx.fillStyle = config.colors.lineHighTech;
        ctx.fillRect(config.padding, config.padding + 10, 20, 10);
        ctx.fillStyle = config.colors.text;
        ctx.fillText('é«˜æ–°äº§ä¸šç‡', config.padding + 30, config.padding + 30);
    }

    return { drawChart };
}

// äº‹ä»¶æ—¶é—´è½´ç³»ç»Ÿ
function initTimeline() {
    const container = document.getElementById('eventContainer');
    
    // åˆ›å»ºäº‹ä»¶å¡ç‰‡
    dataset.events.forEach(event => {
        const card = document.createElement('div');
        card.className = 'event-card';
        card.textContent = event;
        container.appendChild(card);
    });

    return {
        showEvent(index) {
            const cards = container.children;
            if(index < cards.length) {
                cards[index].style.opacity = '1';
                cards[index].style.transform = 'translateY(0)';
            }
        }
    };
}

// åŠ¨ç”»æ§åˆ¶ç³»ç»Ÿ
function initAnimation() {
    const chart = initChart();
    const timeline = initTimeline();
    let currentStep = 0;
    
    // ç‹¬ç«‹åŠ¨ç”»é€Ÿåº¦ï¼ˆå•ä½ï¼šmsï¼‰
    const chartSpeed = 800;
    const eventSpeed = 1200;

    function animateChart() {
        if(currentStep < dataset.years.length) {
            chart.drawChart(currentStep);
            currentStep++;
            setTimeout(animateChart, chartSpeed);
        }
    }

    function animateEvents() {
        let index = 0;
        function showNext() {
            if(index < dataset.events.length) {
                timeline.showEvent(index);
                index++;
                setTimeout(showNext, eventSpeed);
            }
        }
        showNext();
    }

    // å¯åŠ¨åŠ¨ç”»
    setTimeout(() => {
        animateChart();
        animateEvents();
    }, 1000);
}

// åˆå§‹åŒ–ç³»ç»Ÿ
window.addEventListener('load', initAnimation);

// æ»šè½®æ»‘åŠ¨å¡ç‰‡
document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.achievement');
    let isDown = false;
    let startY;
    let scrollTop;

    container.addEventListener('mousedown', (e) => {
        isDown = true;
        startY = e.pageY - container.offsetTop;
        scrollTop = container.scrollTop;
    });

    container.addEventListener('mouseleave', () => {
        isDown = false;
    });

    container.addEventListener('mouseup', () => {
        isDown = false;
    });

    container.addEventListener('mousemove', (e) => {
        if (!isDown) return;
        e.preventDefault();
        const y = e.pageY - container.offsetTop;
        const walk = (y - startY) * 3;
        container.scrollTop = scrollTop - walk;
    });

    container.addEventListener('wheel', (e) => {
        e.preventDefault();
        container.scrollTop += e.deltaY;
    });
});
</script>
</body>
</html>
